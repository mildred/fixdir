#! /bin/zsh

exit_status=0

op_help=false
op_database=
op_destdir=.
op_dry_run=false
op_list_files=false
op_list_ignores=false
op_normal_run=true

while true; do
    case "$1" in
        --help) op_help=true; break ;;
        --dry-run)
                op_dry_run=true
                op_normal_run=false
                ;;
        --list-files)
                op_list_files=true
                op_normal_run=false
                ;;
        --list-ignores)
                op_list_ignores=true;
                ;;
        --)     shift; break        ;;
        --*)    echo "`basename "$0"`: unknown option $1" >&2; exit 1 ;;
        -*)
            opts="$1"
            opts="${opts[2,-1]}"
            while [[ -n "$opts" ]]; do
                case "${opts[1]}" in
                    h) op_help=true     ;;
                    n) op_dry_run=true     ;;
                    *) echo "`basename "$0"`: unknown option -${opts[1]}" >&2; exit 1 ;;
                esac
                opts="${opts[2,-1]}"
            done
        ;;
        *) break ;;
    esac
    shift
done

if [[ $# -ge 1 ]]; then
    op_database="$1"
    shift
fi
if [[ $# -ge 1 ]]; then
    op_destdir="$2"
    shift
fi

# http://en.wikipedia.org/wiki/ANSI_color
c_u="\033[4m" # underline
c_b="\033[1m" # bold
c_b_black="\033[1;30m"
c_b_red="\033[1;31m"
c_b_green="\033[1;32m"
c_b_yellow="\033[1;33m"
c_b_blue="\033[1;34m"
c_b_magenta="\033[1;35m"
c_b_cyan="\033[1;36m"
c_b_white="\033[1;37m"
c_black="\033[30m"
c_red="\033[31m"
c_green="\033[32m"
c_yellow="\033[33m"
c_blue="\033[34m"
c_magenta="\033[35m"
c_cyan="\033[36m"
c_white="\033[37m"
c="\033[1;0m"

msg(){
    mode="$1"
    shift
    case "$mode" in
        t)
            echo -e "$c_b_white$*$c"
            ;;
        e)
            echo -e "$c_b_red==>$c $c_b_white$*$c" >&2
            ;;
        q)
            echo -ne "$c_b_cyan$*$c " >&2
            ;;
        l)
            echo -e "$c_cyan$*$c " >&2
            ;;
        *)
            echo "$@"
            ;;
    esac
}

if $op_dry_run; then
    log(){
        msg l "$@"
    }
else
    log(){
        msg l "$@"
        "$@"
        return "$?"
    }
fi

ask(){
    msg q $*
    read -k 1 ask
    ask="`echo "$ask" | tr 'A-Z' 'a-z'`"
    [[ "`echo`" != "$ask" ]] && echo
}
ask-default-yes(){
    ask "$1 (Y/n)"
    [[ "n" != "$ask" ]] && return 0 || return 1
}
ask-default-no(){
    ask "$1 (y/N)"
    [[ "y" != "$ask" ]] && return 1 || return 0
}

if ! $op_help && [[ -z $op_database ]] && [[ -z $op_destdir ]]; then
    msg e "Error: missing database or destination directory"
    op_help=true
    exit_status=1
fi

if $op_help; then
    msg t  "NAME"
    msg -  ""
    msg -  "    `basename "$0"` - maintain a list of symbolic links"
    msg -  ""
    msg t  "SYNOPSYS"
    msg -  ""
    msg -  "    ${c_b}`basename "$0"`${c} [ ${c_u}OPTIONS${c} ] ${c_u}DATABASE${c} [ ${c_u}DESTDIR${c} ]"
    msg -  "    ${c_b}`basename "$0"`${c} [ ${c_u}OPTIONS${c} ] ${c_u}SRCDIR${c} [ ${c_u}DESTDIR${c} ]"
    msg -  ""
    msg t  "DESCRIPTION"
    msg -  ""
    msg -  "    Updates ${c_u}DESTDIR${c} with sylinks pointing to files present"
    msg -  "    in ${c_u}DATABASE${c}."
    msg -  ""
    msg -  "    If the ${c_u}DATABASE${c} is not provided, is searched in:"
    msg -  "        ${c_u}SRCDIR${c}/database.sh"
    msg -  ""
    msg -  "    The default value for ${c_u}DESTDIR${c} is ${c_b}.${c} and the"
    msg -  "    ${c_u}SRCDIR${c} must be relative to ${c_u}DESTDIR${c}"
    msg -  ""
    msg t  "OPTIONS"
    msg -  ""
    msg -  "    ${c_b}-h${c}, ${c_b}--help${c}"
    msg -  "        Display this help"
    msg -  ""
    msg -  "    ${c_b}-n${c}, ${c_b}--dry-run${c}"
    msg -  "        Don't do anything"
    msg -  ""
    msg -  "    ${c_b}--list-files${c}"
    msg -  "        List files that are not links nor ignored in database"
    msg -  ""
    msg -  "    ${c_b}--list-ignores${c}"
    msg -  "        List ignored files in database"
    msg -  ""
    exit $exit_status
fi

line(){:}
ignore(){:}
follow(){:}

if [[ -d $op_database ]]; then
    srcdir=$op_database
    database=$srcdir/database.sh
else
    srcdir="`dirname $op_database`"
    database=$op_database
fi
destdir=$op_destdir

srcdir_r=$srcdir

reversepath(){
    # $1 is the path to go from A to B
    # then this function returns the path to go from B to A
    if echo "$1" | grep '\.\.' >/dev/null; then
        echo "Error, malformed entry in the database." >&2
        echo "The entry contains '..'. This is not accepted." >&2
        echo "Entry: $1" >&2
        exit 1
    fi
    [ "a." = "a$1" ] && { echo '.'; return; }
    echo "$1" \
        | sed 's|^\.$||'        \
        | sed 's|^\(\./\)*||'   \
        | sed 's|/\./|/|g'      \
        | sed 's|\(/\.\)*$||'   \
        | sed 's|[^/]*|..|g'    \
        | sed 's|^$|.|g'
}

if $op_normal_run; then
    line(){
        pushd $destdir
        local srcname="$1"
        local destname="$2"
        local dir="`dirname "$destname"`"
        local rdir="`reversepath "$dir"`"
        # rdir is the path that goes from where the destfile is to the destdir
        if [[ -e "$destname" ]]; then
            # target already exists
            if [[ -L "$destname" ]]; then
                # Target is a link
                local target="$(
                    stat -c %N "$destname" | \
                    sed -r "s/\`.*' -> \`(.*)'/\1/" )"
                if [[ a"$rdir/$srcdir_r/$srcname" = a"$target" ]]; then
                    # target is pointing to source, pass
                    return 0
#                 else
#                     msg - "$rdir/$srcdir_r/$srcname" != "$target"
                fi
            fi
            # target is not pointing to source (or is not a link)
            msg -
            msg - "Current file name: $c_b$destname$c (already exists)"
            if [[ -L "$destname" ]]; then
                stat -c "             link: %N" "$destname"
            else
                stat -c "             type: %F  size: %s" "$destname"
            fi
            if [[ ! -e "$srcdir_r/$srcname" ]]; then
                msg - "Source does not exists: $c_b$srcdir_r/$srcname$c"
            fi
            if [[ -e "$srcdir_r/$srcname" ]]; then
                # source exists
                msg -   "Create link:       \`$destname' -> \`$rdir/$srcdir_r/$srcname'"
                if ask-default-no "Replace file $c_b$destname$c ?"; then
                    log rm -ri "$destname"
                else
                    # Pass
                    return 0
                fi
            else
                # source do not exists
                msg - "Move: \`$destname' -> \`$srcdir_r/$srcname'"
                msg - "Create link: \`$destname' -> \`$rdir/$srcdir_r/$srcname'"
                if ask-default-no "Continue ?"; then
                    log mkdir -p "`dirname "$localdir/$cfgname"`"
                    log mv "$homename" "$localdir/$cfgname"
                else
                    # Pass
                    return 0
                fi
            fi
        else
            # target do not exists
            if [[ -e "$srcdir_r/$srcname" ]]; then
                # link source to target
                msg -
                msg - "Create link: \`$destname' -> \`$rdir/$srcdir_r/$srcname'"
            else
                # source do not exists either, ignore
                return 0
            fi
        fi
        log mkdir -p "$dir"
        log ln -s "$rdir/$srcdir_r/$srcname" "$destname"
        popd
        return 0
    }
fi

if $op_list_files; then
    ignored_patterns=()
    ignored_files=()
    follow_patterns=()
    follow_files=()
    ignore(){
        case $1 in
            regex)
                ignored_patterns=($ignored_patterns $@[2,-1])
                ;;
            *)
                ignored_files=($ignored_files $@[2,-1])
                ;;
        esac
    }
    line(){
        ignored_files=($ignored_files "$2")
    }
    follow(){
        case $1 in
            regex)
                follow_patterns=($follow_patterns $@[2,-1])
                ;;
            *)
                follow_files=($follow_files $@[2,-1])
                ;;
        esac
    }
fi

if $op_list_ignores; then
    ignore(){
        echo "$@"
    }
    line(){
        echo path "$2"
    }
fi

pushd $destdir

if [[ ! -f "$database" ]]; then
    msg e "Error: The database is missing: $database"
    exit 1
fi

source $database

popd

list_files(){
    local default_follow="$1"
    local prefix="$2"
    local f=
    local ign=
    local ff=
    setopt NULL_GLOB
    for f in * .*; do
        local ignore=false
        for ign in $ignored_patterns; do
            egrep "$ign" <<<"$f" >/dev/null && ignore=true
        done
        for ign in $ignored_files; do
            [[ a"$ign" = a"$f" ]] && ignore=true
        done
        if ! $ignore; then
            echo "$prefix$f"
        fi
        if [[ -d $f ]]; then
            local follow=$default_follow
            for ff in $follow_patterns; do
                egrep "$ff" <<<"$f" >/dev/null && follow=true
            done
            for ff in $follow_files; do
                [[ a"$ff" = a"$f" ]] && follow=true
            done
            if $follow; then
                pushd $f
                list_files $default_follow "$prefix$f/"
                popd
            fi
        fi
    done
    unsetopt NULL_GLOB
}

if $op_list_files; then
    pushd $destdir
    list_files false
    popd
fi

exit $exit_status
